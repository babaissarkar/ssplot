/*
 * My own plotting library written in Java.
 * Subhraman Sarkar.
 */

//TODO : Remove all magic numbers (all unexplained numbers).

package math.plot;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.FontMetrics;
import java.awt.RenderingHints;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.Path;
import java.util.Vector;
import javax.swing.AbstractAction;
import javax.swing.JLabel;
import javax.swing.KeyStroke;
import javax.swing.JOptionPane;

@SuppressWarnings("serial")
public class PlotView extends JLabel {
	public BufferedImage buff; /* The plot */
	private int dx = 0, dy = 0;
	private int Xmax = 620, Ymax = 620, Xmin = 20, Ymin = 20;
    private int W, H; /* Width and Height of the plot */
	private int moveX = 0, moveY = 0;
	private double scaleFactor = 1;
    
    public Point2D.Double mpos;
	
	// Actions
	private LeftAction move_left = new LeftAction();
	private RightAction move_right = new RightAction();
	private UpAction move_up = new UpAction();
	private DownAction move_down = new DownAction();
	private ZoomInAction zoom_in = new ZoomInAction();
	private ZoomOutAction zoom_out = new ZoomOutAction();

    /* Data for this plot */
    private Path datafile;
	public Vector<PlotData> data = null;
	
    /* Plot appearance variables */
    //public enum PlotType { LINES, POINTS, LP, VECTORS };
    //public enum PointType { SQUARE, CIRCLE };
    private PlotData.PlotType curPlotType = PlotType.LINES;
    private PlotData.PointType curPointType = PointType.SQUARE;
    private int colX = 1, colY = 2; /* By default column 1 is xdata, col. 2 is ydata */
    private int ptX = 2, ptY = 2; // Point Size
    private Color curPlotColor = Color.RED, curPlotColor2 = Color.BLUE;

    /* Tics */
    private int noOfMajorTics = 10;
    //private int noOfMinorTics = 5; // No of minor tics in the interval between to major tics
	

    public PlotView() {
        this(null);
    }

	public PlotView(Path dpath) {
        W = Xmax-Xmin;
        H = Ymax-Ymin;

        mpos = null;
        
		buff = new BufferedImage(W, H, BufferedImage.TYPE_INT_ARGB);
		
		datafile = dpath;
        data = new Vector<PlotData>();
		
		// Setting Keybinding for movement
		getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0, false), "left");
		getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0, false), "right");
		getInputMap().put(KeyStroke.getKeyStroke("UP"), "up");
		getInputMap().put(KeyStroke.getKeyStroke("DOWN"), "down");
		getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_J, 0, false), "plus");
		getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F, 0, false), "minus");
		
		getActionMap().put("left", move_left);
		getActionMap().put("right", move_right);
		getActionMap().put("up", move_up);
		getActionMap().put("down", move_down);
		getActionMap().put("plus", zoom_in);
		getActionMap().put("minus", zoom_out);

	}	
	
	@Override
	public void paint(Graphics g) {
		Graphics2D g2 = buff.createGraphics();
		RenderingHints rh = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		g2.setRenderingHints(rh);
		drawGraph(g2);
		g2.dispose();
		g.drawImage(buff, 20, 20, null);
	}

	public void drawGraph(Graphics2D g2) {
		// Instructions to draw the graph
		
		g2.fill(new Rectangle2D.Double(0, 0, W, H));
		resetAxes();
		shiftAxes(W/2,H/2);
		drawAxes(g2);
        drawTics(g2);
		drawBoundingBox(g2);
        
        for (PlotData pdata : data) {
            plotData(g2, pdata, colX, colY);
        }

        /*
        if (mpos != null) {
            updateMousePosition(g2);
        }*/
	}

    /***********************
     *  Drawing Primitives *
     ***********************/

    /* Transforms from Cartesian space to Java Graphics space. */
    /* Takes care of scaling and translation */
	public Point2D.Double getTransformedPoint(Point2D.Double p) {
        double x = p.x;
        double y = p.y;
		double x1 = scaleFactor*x + dx + moveX;
		double y1 = H - (scaleFactor*y + dy + moveY);
		return new Point2D.Double(x1, y1);
	}

    /* Transforms from Java Graphics space to Cartesian space. */
    /* Takes care of scaling and translation */
    public Point2D.Double getInvTransformedPoint(Point2D.Double p1) {
        double x1 = p1.x;
        double y1 = p1.y;
        double x = (x1 - dx - moveX)/scaleFactor;
        double y = (H - y1 - dy - moveY)/scaleFactor;
        return new Point2D.Double(x, y);
    }

    
	/* Converts point in polar form to cartesian form.*/
	public Point2D.Double getCartersianPoint(double r, double theta) {
		double x = r * Math.cos(theta) + dx;
		double y = r * Math.sin(theta) - dy;
		Point2D.Double p = getTransformedPoint(x, y);
		return p;
	}
     
    /* Draw the X and Y axes */
	public void drawAxes(Graphics2D g) {
		Color curColor = g.getColor();
		g.setColor(Color.BLACK);

        g.drawLine(dx, 0, dx, W);
        g.drawLine(0, dy, H, dy);
		g.setColor(curColor);
	}

    /* Draw tics along the axes */
	public void drawTics(Graphics2D g) {
        Color curColor = g.getColor();
		g.setColor(Color.BLACK);
        FontMetrics m = g.getFontMetrics();
        
        for (int i = -(noOfMajorTics/2 - 1); i < noOfMajorTics/2; i++) {
            // X axis tics
            int x =  i * W/noOfMajorTics;
            double lbl = x/scaleFactor;
            String strLbl;
            
            
            if ((Math.abs(lbl) >= 0.1) && (Math.abs(lbl) < 10)) {
                strLbl = String.format("%2.1f", lbl);
            } else if ((Math.abs(lbl) >= 10) && (Math.abs(lbl) < 1000)) {
                strLbl = String.format("%3.0f", lbl);
            } else {
                strLbl = String.format("%2.1e", lbl);
            }
            
            int strWidth = m.stringWidth(strLbl);
            int strHeight = m.getHeight();
            
            g.drawLine(x + dx, W/2, x + dx, W/2 + 5);
            if (i != 0) {
                g.drawString(strLbl, x+dx - strWidth/2 - 2, W/2 + strHeight + 3);

                // Tic labels in scientific notation (ie. 1e13)
                // Different scale factors for X and Y axes
            }
            // Y axis tics
            int y = i * H/noOfMajorTics;
            g.drawLine(H/2 - 5, y + dy, H/2, y + dy);
            if (i != 0) {
                g.drawString(strLbl, H/2 - strWidth - 8, y+dy + strHeight/2 - 2);
            }
        }
        
        g.setColor(curColor);
	}

    /* Draws a box around the plot */
	public void drawBoundingBox(Graphics2D g) {
        int strokeWidth = 1;
        Color curColor = g.getColor();
        g.setColor(Color.BLUE);
        
        g.drawLine(0, 0, 0, H);
        /* Correction for finite thickness of the line */
        g.drawLine(0, H-strokeWidth, W, H-strokeWidth);
        g.drawLine(W-strokeWidth, H, W-strokeWidth, 0);
        g.drawLine(W, 0, 0, 0);

        g.setColor(curColor);
	}

    /* Draws a point.*/
	public void drawPoint(Graphics2D g, Point2D.Double p) {
        if (curPointType == PlotData.PointType.SQUARE) {
            g.fill(new Rectangle2D.Double(p.x, p.y, ptX, ptY));
        } else if (curPointType == PlotData.PointType.CIRCLE) {
            g.fill(new Ellipse2D.Double(p.getX(), p.getY(), ptX, ptY));
        }
	}
	
	/* Draws a lines from point q1 to point q2 */
	public void drawLine(Graphics2D g, Point2D.Double q1, Point2D.Double q2) {
        g.draw(new Line2D.Double(q1, q2));
	}
	
	/* Draws an vector, by drawing a line with a marker.*/
	public void drawVector(Graphics2D g, Point2D.Double q1, Point2D.Double q2) {
		g.setStroke(new BasicStroke(1.0f));
        g.setColor(curPlotColor2);
        g.draw(new Ellipse2D.Double(q1.x - 1, q1.y - 1, 2, 2));
        g.setColor(curPlotColor);
		//g.draw(new Ellipse2D.Double(q2.x - 2, q2.y - 2, 4, 4));
        drawArrowTip(g, q1, q2);
		drawLine(g, q1, q2);
		g.setStroke(new BasicStroke(1f));
	}

    public void drawArrowTip(Graphics2D g, Point2D.Double q1, Point2D.Double q2) {
        double tipLen = (q1.distance(q2))/10;
        double tipAngle = Math.toRadians(15);
        
        double arrowAngle = Math.atan2((q2.y - q1.y), (q2.x - q1.x));
        
        double tipEndX1 = q2.x - tipLen * Math.cos(tipAngle - arrowAngle);
        double tipEndY1 = q2.y + tipLen * Math.sin(tipAngle - arrowAngle);
        Point2D.Double tipEnd1 = new Point2D.Double(tipEndX1, tipEndY1);
        g.draw(new Line2D.Double(q2, tipEnd1));

        double tipEndX2 = q2.x - tipLen * Math.cos(-tipAngle - arrowAngle);
        double tipEndY2 = q2.y + tipLen * Math.sin(-tipAngle - arrowAngle);
        Point2D.Double tipEnd2 = new Point2D.Double(tipEndX2, tipEndY2);
        g.draw(new Line2D.Double(q2, tipEnd2));
    }
	
	/* Write text at a specific point */
	public void drawText(Graphics2D g, String str, Point2D.Double p) {
		g.drawString(str, (int) p.x, (int) p.y);
	}

	/* Sets size of a single point */
	/* This sets the width of line and vector as well */
	public void setPointSize(int w, int h) {
		ptX = w; ptY = h;
	}

	
	/* Sets the foreground color from rgb code */
	/* All components (r,g,b) are from 0 to 255 */
	private void setFGColor(Graphics2D g2, int r, int g, int b) {
		Color cl = new Color(r, g, b); 
		g2.setColor(cl);
	}

    private void updateColor(Graphics2D g2, Color c) {
        setFGColor(g2, curPlotColor.getRed(), curPlotColor.getGreen(), curPlotColor.getBlue());
    }

    /**************
     *  Settings  *
     **************/

    public void setCurPlotType(PlotData.PlotType newCurPlotType) {
        curPlotType = newCurPlotType;

        JOptionPane.showMessageDialog(this, "Plot Type : " + newCurPlotType);
    }

    public PlotData.PlotType getCurPlotType() {
        return curPlotType;
    }

    public void setCurPointType(PlotData.PointType newCurPointType) {
        curPointType = newCurPointType;
    }

    public void setCurColor(Color col) {
        curPlotColor = col;
    }
     


    /************************
     *  Interface Functions *
     ************************/

    /* Refreshes the canvas */
	public void refresh() {
		buff = new BufferedImage(Xmax-Xmin, Ymax-Ymin, BufferedImage.TYPE_INT_ARGB);
		repaint();
	}
    
	/* Shifts the axes */
	public void shiftAxes(int x, int y) {
		dx = x;
		dy = y;
	}
	
	/* Sets the axes at x=0 and y=0 */
	public void resetAxes() {
		dx = 0;
		dy = 0;
	}
	
	
	/* Changes plot scale */
	public void changeBounds(int Xmin, int Ymin, int Xmax, int Ymax) {
		this.Xmax = Xmax;
		this.Xmin = Xmin;
		this.Ymax = Ymax;
		this.Ymin = Ymin;
	}
	
	public void resetBounds() {
        /* Needs to be setup from the width and height of the canvas */
		changeBounds(20, 20, 620, 620);
	}
	
	public void setZoom(double zoom) {
		scaleFactor = zoom;
	}
	

    /******************
     *    Movement    *
     ******************/
    
	// Actions work, but need to be upgraded
	// It's no use moving the entire graph around!
	public class LeftAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			moveX -= 10;
			repaint();
		}
	}
	
	public class RightAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			moveX += 10;
			repaint();
		}
	}
	
	public class UpAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			moveY += 10;
			repaint();
		}
	}
	
	public class DownAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			moveY -= 10;
			repaint();
		}
	}
	
	public class ZoomInAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			scaleFactor *= 2;
			repaint();
		}
	}
	
	public class ZoomOutAction extends AbstractAction {
		@Override
		public void actionPerformed(ActionEvent arg0) {
			scaleFactor /= 2;
			repaint();
		}
	}


    /*************
     *  Datafile *
     *************/

    /* Plots the data currently loaded.
	 * Plots the data of column col1 of datafile as X data
     * and col2 as Y data.
	 */
    public void plotData(Graphics2D g2, PlotData pdata, int col1, int col2)
    {
        if (data != null) {
            //int i = 0;
        
            Point2D.Double p1 = null, p2 = null;
            
            Vector<Vector<Double>> dataset = pdata.data;
            curPlotColor = pdata.fgColor;
            curPlotColor2 = pdata.fgColor2;

            updateColor(g2, curPlotColor);
            
            for (Vector<Double> row : dataset) {
                if (pdata.pltype == PlotData.PlotType.VECTORS) {
                    /* For now, it works for vector data in first four columns only */
                    if (row.size() >= 4) {
                        p1 = getTransformedPoint(row.get(0), row.get(1));
                        p2 = getTransformedPoint(row.get(2), row.get(3));
                        
                        drawVector(g2, p1, p2);
                    } else {
                        showMsg("Bad vector field data!");
                    }
                } else {
                    p2 = getTransformedPoint(row.get(col1-1), row.get(col2-1));
                    if (p1 != null) {
                        switch(pdata.pltype) {
                            case LINES :
                                drawLine(g2, p1, p2);
                                break;
                            case POINTS :
                                drawPoint(g2, p1);
                                break;
                            default :
                                // TODO
                                break;
                        }
                    }
                    p1 = p2;
                }
            }
            //i++;
        }

    }

	public void viewDatafile() {
        if (datafile != null) {
            try {
                setData(NumParse.parse(datafile));
                //plotData();
            } catch (IOException e) {
                showMsg("Error loading Datafile : " + e.getMessage());
            }
        }
	}

	/**
	 * @return the datafile
	 */
	public Path getDatafile() {
		return datafile;
	}

	/**
	 * @param the datafile to set
	 */
	public void setDatafile(Path datafile) {
		this.datafile = datafile;
	}
    
    public Vector<Vector<Double>> getData() {
        return data.lastElement();
    }

    public void setData(Vector<Vector<Double>> dataset) {
        data.add(dataset);
        repaint();
    }

    public void clear() {
        data = new Vector<Vector<Vector<Double>>>();
        mpos = null;
		buff = new BufferedImage(W, H, BufferedImage.TYPE_INT_ARGB);
        System.out.println("Buffer reset.");
		//datafile = dpath;
        repaint();
    }

    
    public void updateMousePosition(Graphics2D g2) {
        Point2D.Double offset = new Point2D.Double(20, 20);
        Point2D.Double mposTrans = getInvTransformedPoint(mpos.x - offset.x, mpos.y - offset.y);

        String mousePos = "(" + mposTrans.x + "," + mposTrans.y + ")";
        drawText(g2, mousePos, mpos);
    }

    /***********************
     *   Other functions   *
     ***********************/
    

    public void showMsg(String msg) {
        //JOptionPane.showMessageDialog(new JFrame(), msg);
        System.out.println(msg);
    }

}
